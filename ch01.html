<!doctype html>
<html lang="en">

<head>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Study guide for the Oracle Certified Professional, Java SE 8 Programmer Exam ">
    <title>Java 8 Programmer II Study Guide: Exam 1Z0-809</title>
    <link href="css/code.css" rel="stylesheet" type="text/css" />
    <link href="css/style.css" rel="stylesheet" type="text/css" />
    <link href="https://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>

    <script src="js/common-sections.js"></script>
</head>

<body>

    <div class="nav"></div>

    <div class="header">
        <div class="title-container">
            <div class="chapter-title">
                <h1><i class="chapter">Part ONE</i><br />
			  Class Design</h1>

                <h1><i style="text-align: center;">Chapter ONE</i><br />
			  Encapsulation and Immutable Classes</h1>

                <h3 style="text-align: center;"><i>Exam Objectives</i></h3>

                <p style="text-align: center;"><i>Implement encapsulation.<br />
			  Override hashCode, equals, and toString methods from Object class.<br />
			  Create and use singleton classes and immutable classes.<br />
			  Develop code that uses static keyword on initialize blocks, variables, methods, and classes.<br />
			  Develop code that uses final keyword.</i><br /></p>

            </div>
        </div>
    </div>



    <div class="container">

        <div class="column">

            <h2>Encapsulation</h2>

            <p>As we know, Java is an object-oriented language, and all code must be inside a class.</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span> {<br />
	  &nbsp; &nbsp; String myField = <span class="hljs-string">"you"</span>;<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Hi "</span> + myField);<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Therefore, we have to create an object to use it:</p>

            <p><code class="java hljs">MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br />
	  myClass.myField = <span class="hljs-string">"James"</span>;<br />
	  myClass.myMethod();</code></p>

            <p>One important concept in object-oriented programming languages is encapsulation, the ability to hide or protect an object's data.</p>

            <p>Most of the time, when someone talks about encapsulation most people tend to think about private variables and public getters and setters and how overkilling this is, but actually, encapsulation is more than that, and it's helpful to create high-quality designs.</p>

            <p>Let's consider the previous example.</p>

            <p>First of all, it's good to hide as much as possible the internal implementation of a class. The reason, mitigate the impact of change.</p>

            <p>For example, what if <code>myField</code> changes its type from <code>String</code> to <code>int</code>?</p>

            <p><code class="java hljs">myClass.myField = <span class="hljs-number">1</span>;</code></p>

            <p>If we were using this attribute in fifty classes, we would have to make fifty changes in our program.</p>

            <p>But if we hide the attribute and use a setter method instead, we could avoid the fifty changes:</p>

            <p><code class="java hljs"><span class="hljs-comment">// Hiding the attr to the outside world with the private keyword</span><br />
	  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> myField = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword"><br />
	  void</span> <span class="hljs-title">setMyField</span><span class="hljs-params">(String val)</span></span> { <span class="hljs-comment">// Still accepting a String</span><br />
	  <span class="hljs-keyword">&nbsp; &nbsp; try</span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; myField = Integer.parseInt(val);<br />
	  &nbsp; &nbsp; } <span class="hljs-keyword">catch</span>(NumberFormatException e) {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; myField = <span class="hljs-number">0</span>;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>You implement this attribute hiding by using access modifiers.</p>

            <p>Java supports four access modifiers:</p>

            <ul>
                <li><b>public</b></li>

                <li><b>private</b></li>

                <li><b>protected</b></li>

                <li><b>default</b> (when no modifier is specified)</li>
            </ul>

            <p>You can apply these modifiers to classes, attributes and methods according to the following table:</p>

            <table border="1" width="100%">
                <tr>
                    <td></td>

                    <td rowspan="2" style="text-align: center;"><b>Class/<br />
		  Interface</b></td>

                    <td colspan="2" style="text-align: center;"><b>Class</b></td>

                    <td colspan="2" style="text-align: center;"><b>Interface</b></td>
                </tr>

                <tr>
                    <td></td>

                    <td style="text-align: center;"><b>Attrib</b></td>

                    <td style="text-align: center;"><b>Method</b></td>

                    <td style="text-align: center;"><b>Attrib</b></td>

                    <td style="text-align: center;"><b>Method</b></td>
                </tr>

                <tr>
                    <td><b>public</b></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>
                </tr>

                <tr>
                    <td><b>private</b></td>

                    <td></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td></td>

                    <td></td>
                </tr>

                <tr>
                    <td><b>protected</b></td>

                    <td></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td></td>

                    <td></td>
                </tr>

                <tr>
                    <td><b>default</b></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>
                </tr>
            </table>

            <p>As you can see, all the access modifiers can be applied to attributes and methods of a class, but not necessarily to their interface counterparts. Also, class and interface definitions can only have a <code>public</code> or default modifier. Why? Let's define first these access modifiers.</p>

            <p>If something is declared as <code>public</code>, it can be accessed from any other class of our application, regardless of the package or the module it is defined.</p>

            <p>If something is defined as <code>private</code>, it can only be accessed inside the class that defines it, not from other classes in the same packages and not from classes that inherit the class. <code>private</code> is the most restrictive access modifier.</p>

            <p>If something is defined as <code>protected</code>, it can be only accessed by the class that defines it, its subclasses and classes of the same package. It doesn't matter if the subclass is in another package, which makes this modifier less restrictive than <code>private</code>.</p>

            <p>If something doesn't have a modifier, it has default access also known as package access, because it can only be accessed by classes within the same package. If a subclass is defined in another package, it cannot see the default access attribute or method. That is the only difference with the <code>protected</code> modifier, which makes it more restrictive.</p>

            <p>A code example may explain this better:</p>

            <p><code class="java hljs"><span class="hljs-keyword">package</span> street21;<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; protected</span> <span class="hljs-keyword">int</span> number;<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> String reference;<br />
	  <span class="hljs-function"><span class="hljs-keyword"><br />
	  &nbsp; &nbsp; void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Num: "</span> + number);<br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInformation</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Num: "</span> + number);<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Ref: "</span> + reference);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlueHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">House</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span></span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"BLUE"</span>; }<br />
	  }<br />
	  <br />
	  ...<br />
	  <br />
	  <span class="hljs-keyword">package</span> city;<br />
	  <span class="hljs-keyword">import</span> street21.*;<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">House</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; GenericHouse h = <span class="hljs-keyword">new</span> GenericHouse();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; h.number = <span class="hljs-number">100</span>;<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; h.reference = <span class="hljs-string">""</span>; <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; h.printNumber(); <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; h.printInformation();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; BlueHouse bh = <span class="hljs-keyword">new</span> BlueHouse(); <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; bh.getColor(); <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <ul>
                <li><code>h.number</code> compiles because this attribute is <code>protected</code> and <code>GenericHouse</code> can access it because it extends <code>House</code>.</li>

                <li><code>h.reference</code> doesn't compile because this attribute is <code>private</code>.</li>

                <li><code>h.printNumber()</code> doesn't compile because this method has default (package) access.</li>

                <li><code>h.printInformation()</code> compiles because this method is <code>public</code>.</li>

                <li><code>BlueHouse bh = new BlueHouse()</code> doesn't compile because the class has default (package) access.</li>

                <li><code>bh.getColor()</code> doesn't compile because although the method is <code>public</code>, the class that contains it, it's not.</li>
            </ul>

            <p>Now, can you see why some modifiers apply to certain elements, and others don't?</p>

            <p>Would a <code>private</code> or <code>protected</code> class make sense in an object-oriented language?</p>

            <p>How about a <code>private</code> method inside an interface where most, if not all methods, have no implementation?</p>

            <p>Think about it.</p>

            <p>Here's a summary of the rules:</p>

            <table border="1" width="100%">
                <tr>
                    <td></td>

                    <td style="text-align: center;"><b>Members same class</b></td>

                    <td style="text-align: center;"><b>Subclass same package</b></td>

                    <td style="text-align: center;"><b>Subclass different package</b></td>

                    <td style="text-align: center;"><b>Another class same package</b></td>

                    <td style="text-align: center;"><b>Another class different package</b></td>
                </tr>

                <tr>
                    <td><b>public</b></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>
                </tr>

                <tr>
                    <td><b>private</b></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;"></td>

                    <td style="text-align: center;"></td>

                    <td style="text-align: center;"></td>

                    <td style="text-align: center;"></td>
                </tr>

                <tr>
                    <td><b>protected</b></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;"></td>
                </tr>

                <tr>
                    <td><b>default</b></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;"></td>

                    <td style="text-align: center;">X</td>

                    <td style="text-align: center;"></td>
                </tr>
            </table>

            <h2>What is a Singleton?</h2>

            <p>There will be times when you might want to have only one instance for a particular class. Such a class is a <i>singleton</i> class and is a design pattern.</p>

            <p>There are some classes of Java that are written using the singleton pattern, for example:</p>

            <ul>
                <li><code>java.lang.Runtime</code></li>

                <li><code>java.awt.Desktop</code></li>
            </ul>

            <p>In Java, broadly speaking, there are two ways to implement a singleton class:</p>

            <ul>
                <li>With a <code>private</code> constructor and a <code>static</code> factory method</li>

                <li>As an enum</li>
            </ul>

            <p>Let's start with the private constructor way. Although it might seem simple at first, it poses many challenges, all of them related to keeping only one instance of a singleton class through all the application life cycle.</p>

            <p>By having a <code>private</code> constructor, the singleton class makes sure that no other class creates an instance of it. A <code>private</code> method (or in this case, the constructor) can only be used inside the class that defines it.</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  }</code></p>

            <p>So the instance has to be created inside of the class itself.</p>

            <p>This can be done in two ways. Using a <code>private static</code> attribute and a method to get it:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>&nbsp;Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span>&nbsp;<span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; return</span> instance;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The attribute has to be <code>private</code> so no other class can use it, only through its getter.</p>

            <p>It has to be <code>static</code> so the instance can be created when the class is loaded before anyone can use it and because <code>static</code> members belong to the class and not to a particular instance.</p>

            <p>And it has to be <code>final</code> so a new instance cannot be created later.</p>

            <p>A variation of this implementation is to use a <code>static</code> inner class (we will review this type of class on Chapter 3):</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance&nbsp;=<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new</span> Singleton();<br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;public</span>&nbsp;<span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; return</span> Holder.instance;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The advantage of this is that the instance won't be created until the inner class is referenced for the first time.</p>

            <p>However, there will times when for example, creating the object is not as simple as calling <code>new</code>, so the other way is to create the instance inside the <code>get</code> method:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> Singleton instance;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span>&nbsp;<span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; if</span>(instance == <span class="hljs-keyword">null</span>) {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = <span class="hljs-keyword">new</span> Singleton();<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // more code to create the instance...</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">return</span> instance;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The first time this method is called, the instance will be created. But with this approach, we face another problem. In a multithreading environment, if two or more threads are executing this method in parallel, there's a significant risk of ending up with multiple instances of the class.</p>

            <p>One solution is to synchronize the method so only one thread at a time can access it.</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> Singleton instance;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span>&nbsp;<span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; if</span>(instance == <span class="hljs-keyword">null</span>) {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = <span class="hljs-keyword">new</span> Singleton();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; return</span> instance;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The problem with this is that strictly speaking, is not very efficient. We only need synchronization the first time, when the instance is created, not every single time the method is called.</p>

            <p>An improvement is to lock only the portion of the code that creates the instance. For this to work properly, we have to double check if the instance is <code>null</code>, one without locking (to check if the instance is already created), and then another one inside a <code>synchronized</code> block (to safely create the instance).</p>

            <p>Here's how this would look:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> Singleton instance;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span>&nbsp;<span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; if</span>(instance == <span class="hljs-keyword">null</span>) {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized</span> (Singleton.class) {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if</span>(instance == <span class="hljs-keyword">null</span>) {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = <span class="hljs-keyword">new</span> Singleton();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">return</span> instance;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>But again, this implementation is not perfect yet. This time, the problem is at the Java Virtual Machine (JVM) level. The JVM, or sometimes the compiler, can optimize the code by reordering or caching the value of variables (and not making the updates visible).</p>

            <p>The solution is to use the <code>volatile</code> keyword, which guarantees that any read/write operation of a variable shared by many threads would be atomic and not cached.</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; if</span>(instance == <span class="hljs-keyword">null</span>) {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized</span> (Singleton.class) {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if</span>(instance == <span class="hljs-keyword">null</span>) {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = <span class="hljs-keyword">new</span> Singleton();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; }<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; return</span> instance;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>As you can see, it was a lot of trouble to implement a singleton correctly when you want or have to defer the instantiation of the class until you first use it (also called lazy initialization). And we are not going to cover serialization and how to keep a singleton in a cluster.</p>

            <p>So if you don't need it, either use the first two methods (create the instance when declaring the variable or use the holder inner class) or the easier (and recommended) way, an enumeration (enum).</p>

            <p>We'll review enums in Chapter 5, for now, just knowing that enums are singletons is enough.</p>

            <h2>Immutable Objects</h2>

            <p>There will be other times when you might not want to modify the values or state of an object when used by multiple classes. Such an object will be an <i>immutable</i> object.</p>

            <p>There are some immutable classes in the Java JDK, for example:</p>

            <ul>
                <li><code>java.lang.String</code></li>

                <li>Wrappers classes (like <code>Integer</code>)</li>
            </ul>

            <p>Immutable objects cannot change after they are created. This means that they cannot have setter methods or <code>public</code> variables, so the only way to set its properties is through the constructor.</p>

            <p>Immutability also means that if a method has to change the properties of the object, as the object or its values cannot change, it has to return a copy of the object with the new values (this is just how the <code>String</code> class works).</p>

            <p>Another point to consider is inheritance. If the immutable class can be inherited, the subclass can change the methods to modify the instances of the class, so an immutable class cannot allow this.</p>

            <p>In summary, an immutable object:</p>

            <ul>
                <li>Sets all of its properties through a constructor</li>

                <li>Does not define setter methods</li>

                <li>Declares all its attributes <code>private</code> (and sometimes <code>final</code>)</li>

                <li>Has a class declared <code>final</code> to prevent inheritance</li>

                <li>If it has mutable types (for example a <code>List</code>), either the reference cannot be accessible outside the object or a copy must be returned (the same applies if the object's content must change)</li>
            </ul>

            <h2>The static Keyword</h2>

            <p>Think of something <code>static</code> as something belonging to the class and not to a particular instance of that class.</p>

            <p>If we are talking about attributes, a <code>static</code> attribute is shared across all instances of the class (because, again, it doesn't belong to an instance).</p>

            <p>Compare the output of this code:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">int</span> attr = <span class="hljs-number">0</span>;<br />
	  <br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAttr</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(attr);<br />
	  &nbsp; &nbsp; }<br />
	  <br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Example e1 = <span class="hljs-keyword">new</span> Example();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e1.attr = <span class="hljs-number">10</span>;<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e1.printAttr();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Example e2 = <span class="hljs-keyword">new</span> Example();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e2.printAttr();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Output:</p>

            <p><code class="java hljs"><span class="hljs-number">10</span><br />
	  <span class="hljs-number">0</span></code></p>

            <p>To the output of the code that uses a <code>static</code> variable:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> attr = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword"><br />
	  &nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAttr</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(attr);<br />
	  &nbsp; &nbsp; }<br />
	  <br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Example e1 = <span class="hljs-keyword">new</span> Example();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e1.attr = <span class="hljs-number">10</span>;<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e1.printAttr();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Example e2 = <span class="hljs-keyword">new</span> Example();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e2.printAttr();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Output:</p>

            <p><code class="java hljs"><span class="hljs-number">10</span><br />
	  <span class="hljs-number">10</span></code></p>

            <p>As you can see, the value is retained when another instance uses the <code>static</code> variable.</p>

            <p>When talking about methods, the method belongs to the class, which means that we don't need an instance to call it (the same applies to attributes, by the way.</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> attr = <span class="hljs-number">0</span>;<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAttr</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(attr);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Example e1 = <span class="hljs-keyword">new</span> Example();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e1.attr = <span class="hljs-number">10</span>;<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; e1.printAttr();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-comment">// Referencing the method statically<br /></span>&nbsp; &nbsp; &nbsp; &nbsp; Example.printAttr();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Output:</p>

            <p><code class="java hljs"><span class="hljs-number">10</span><br />
	  <span class="hljs-number">10</span></code></p>

            <p>However, if you look closely, <code>printAttr</code> uses a <code>static</code> attribute, and that's the catch with <code>static</code> methods, they can't use instance variables, just <code>static</code> ones.</p>

            <p>This makes perfect sense, if you can access a <code>static</code> method with just the class, there's no guarantee an instance exists, and even if it does, how do you link an attribute with its instance when you only have the class name?</p>

            <p>Using the same logic, the keywords <code>super</code> and <code>this</code>, cannot be used either.</p>

            <p>Static classes will be covered in Chapter 3, but there's another construct that can be marked as <code>static</code>, an initializer block.</p>

            <p>A <code>static</code> (initializer) block looks like this:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;<br />
	  <span class="hljs-keyword"><br />
	  &nbsp; &nbsp; static</span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; number = <span class="hljs-number">100</span>;<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp; ...<br />
	  }</code></p>

            <p>A block is executed when the class is initialized and in the order they are declared (if there's more than one).</p>

            <p>Just like <code>static</code> methods, they cannot reference instance attributes, or the keywords this and super.</p>

            <p>In addition to that, <code>static</code> blocks cannot contain a <code>return</code> statement, and it's a compile-time error if the block cannot complete normally (for example, due to an uncaught exception).</p>

            <h2>Final Keyword</h2>

            <p>The <code>final</code> keyword can be applied to variables, methods, and classes.</p>

            <p>When <code>final</code> is applied to variables, you cannot change the value of the variable after its initialization. These variables can be attributes (static and non-static) or parameters. Final attributes can be initialized either when declared, inside a constructor, or inside an initializer block.</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> total;<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id;<br />
	  <br />
	  &nbsp; &nbsp; {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; name = <span class="hljs-string">"Name"</span>;<br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword"><br />
	  &nbsp; &nbsp; public</span> <span class="hljs-title">Example</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; number = <span class="hljs-number">1</span>; <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; total = <span class="hljs-number">10</span>;<br />
	  &nbsp; &nbsp; }<br />
	  <br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exampleMethod</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; id = <span class="hljs-number">5</span>; <span class="hljs-comment">// Compile-time error<br /></span><span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; this</span>.id = id; <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>When <code>final</code> is applied to a method, this cannot be overridden.</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> { }<br />
	  }<br />
	  ...<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">talk</span><span class="hljs-params">()</span></span> { } <span class="hljs-comment">// Compile-time error</span><br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> { }<br />
	  }</code></p>

            <p>In turn, when <code>final</code> is applied to a class, you cannot subclass it. This is used when you don't want someone to change the behavior of a class by subclassing it. Two examples in the JDK are <code>java.lang.String</code> and <code>java.lang.Number</code>.</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span> {<br />
	  &nbsp; &nbsp; ...<br />
	  }<br />
	  ...<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span> { <span class="hljs-comment">// Compile-time error</span><br />
	  &nbsp; &nbsp; ...<br />
	  }</code></p>

            <p>In summary:</p>

            <ul>
                <li>A <code>final</code> variable can only be initialized once and cannot change its value after that.</li>

                <li>A <code>final</code> method cannot be overridden by subclasses.</li>

                <li>A <code>final</code> class cannot be subclassed.</li>
            </ul>



            <h2>Key Points</h2>

            <ul>
                <li>Encapsulation is the ability to hide or protect an object's data. Java supports four access modifiers: <code>public</code>, <code>private</code>, <code>protected</code>, default (when nothing is specified, also called package-level).</li>

                <li>If something is declared as <code>public</code>, it can be accessed from any other class of our application. Any class, regardless of the package or the module it is defined.</li>

                <li>If something is defined as <code>private</code>, it can only be accessed inside the class that defines it. Not from other classes in the same packages and not from classes that inherit the class. <code>private</code> is the most restrictive access modifier.</li>

                <li>If something is defined as <code>protected</code>, it can be only accessed by the class that defines it, its subclasses and classes of the same package. It doesn't matter if the subclass is in another package, which makes this modifier, less restrictive than <code>private</code>.</li>

                <li>If something doesn't have a modifier, it has default access also known as package access, because it can only be accessed by classes within the same package. If a subclass is defined in another package, it cannot see it, that's the only difference with the <code>protected</code> modifier, making it more restrictive.</li>

                <li>A singleton class guarantees that there's only one instance of the class during the lifetime of the application.</li>

                <li>An immutable object cannot change its values after it is created and it can be made by:

                    <ul>
                        <li>Setting all its properties through a constructor</li>

                        <li>Don't defining setter methods</li>

                        <li>Declaring all its attributes as private</li>

                        <li>Declaring the class as <code>final</code></li>

                        <li>If it has mutable types (for example a <code>List</code>), either the reference cannot be accessible outside the object or a copy must be returned (the same applies if the object's content must change)</li>
                    </ul>
                </li>

                <li>The <code>static</code> keyword can be applied to attributes, methods, blocks and classes. A <code>static</code> member belongs to the class where is declared, not to a particular instance.</li>

                <li>The <code>final</code> keyword can be applied to variables (so they cannot change their value after initialized), methods (so they cannot be overridden), and classes (so they cannot be subclassed).</li>
            </ul>



            <h2>Self Test</h2>

            <p>1. Given:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_1_1</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">// 1</span><br />
	  <span class="hljs-keyword">&nbsp; &nbsp; static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>; <span class="hljs-comment">// 2</span><br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-title">Question_1_1</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.print(a); <span class="hljs-comment">// 3</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.print(b); <span class="hljs-comment">// 4</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>01</code><br /> B. Compilation fails on the line marked as <code>// 1</code><br /> C. Compilation fails on the line marked as <code>// 2</code><br /> D. Compilation fails on the line marked as <code>// 3</code><br /> E. Compilation fails on the line marked as <code>// 4</code></p>



            <p>2. Which of the following state the correct order from the more restricted modifier to the more unrestricted?<br /> A. <code>private</code>, default, <code>public</code>, <code>protected</code><br /> B. <code>protected</code>, <code>private</code>, default, <code>public</code><br /> C. default, <code>protected</code>, <code>private</code>, <code>public</code><br /> D. <code>private</code>, default, <code>protected</code>, <code>public</code></p>



            <p>3. Given:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_1_3</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-title">Question_1_3</span><span class="hljs-params">()</span></span> { }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span> {&nbsp;<span class="hljs-keyword">this</span>.n = n;&nbsp;}<br />
	  }</code></p>

            <p>Which of the following is true?<br /> A. The class is immutable<br /> B. The class is not immutable<br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>



            <p>4. Given:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_1_4</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">final</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; list.add(<span class="hljs-number">0</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_1_4 q = <span class="hljs-keyword">new</span> Question_1_4();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q.add();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Which of the following is true?<br /> A. Attribute <code>list</code> contains one element after main is executed<br /> B. The class is immutable<br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>



            <p>5. Given:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_1_5</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> String s = <span class="hljs-string">"Hi"</span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_1_5 q = <span class="hljs-keyword">new</span> Question_1_5();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q.s = <span class="hljs-string">"Bye"</span>; <span class="hljs-comment">// 1</span><br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(q.s); <span class="hljs-comment">// 2</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>Hi</code><br /> B. <code>Bye</code><br /> C. Compilation fails on the declaration marked as <code>// 1</code><br /> D. Compilation fails on the declaration marked as <code>// 2</code></p>



            <p>6. Given:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_1_6</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">int</span> b;<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; static</span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; a = <span class="hljs-number">1</span>;<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; b = <span class="hljs-number">2</span>;<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_1_6 q1 = <span class="hljs-keyword">new</span> Question_1_6();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_1_6 q2 = <span class="hljs-keyword">new</span> Question_1_6();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q2.b = <span class="hljs-number">1</span>;<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(q1.a + q2.b);<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>0</code><br /> B. <code>3</code><br /> C. <code>2</code><br /> D. Compilation fails</p>

            <div class="answers">
                <a href="ch01a.html" target="_blank">Open answers page</a>
            </div>

            <div class="book-info"></div>

            <div class="linkbox">
                <div class="previous">
                    &nbsp;
                </div>
                <div class="next">
                    <a href="ch02.html">02. Inheritance and Polymorphism</a>
                </div>
                <div style="clear:both;"></div>
            </div>

        </div>
    </div>

    <footer></footer>

</body>

</html>
